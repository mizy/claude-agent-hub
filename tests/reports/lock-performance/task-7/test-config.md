# 任务7 测试配置详情

## 测试文件信息
- **文件**: `tests/lock-performance-task7.test.ts`
- **创建时间**: 2026-02-03 18:44
- **测试框架**: Vitest ^2.0.3
- **代码行数**: ~380 行

## 测试场景清单

### 1. 基本功能验证（3个场景）

#### S1: 锁的基本获取和释放
```typescript
测试内容:
- 首次获取锁 → 应该成功
- 重复获取锁（已持有）→ 应该返回 true
- 释放锁 → 锁状态应该清除
- 再次获取锁 → 应该成功

验证点:
✓ acquireLock() 返回 true
✓ isLocked() 状态正确
✓ 释放后能重新获取
```

#### S2: 锁状态检查
```typescript
测试内容:
- 初始状态 → 无锁
- 获取锁后 → 已锁定
- 释放锁后 → 无锁

验证点:
✓ isLocked() 准确反映锁状态
```

#### S3: PID 记录和读取
```typescript
测试内容:
- 获取锁后读取 PID
- 验证 PID 与当前进程一致

验证点:
✓ getLockPid() 返回正确的进程 PID
✓ 锁文件内容格式正确
```

---

### 2. 初步性能测试（2个场景）

#### S4: 单次操作延迟（100次迭代）
```typescript
参数:
- 迭代次数: 100
- 操作: withLock(() => {})（空操作）

收集指标:
- min: 最小延迟
- max: 最大延迟
- avg: 平均延迟
- p50: 中位数
- p95: 95分位数
- p99: 99分位数

观察点（非强制阈值）:
- < 1ms → 良好
- 1-5ms → 可接受
- > 5ms → 需要优化

断言:
- 仅验证所有迭代完成
```

#### S5: 简单并发测试（3个并发进程）
```typescript
参数:
- Worker 数量: 3
- 每个 Worker 操作数: 30
- 总操作数: 90
- 操作: 并发写入队列文件

收集指标:
- 成功操作数 / 总操作数
- 总耗时
- 平均延迟
- 错误数
- 写入任务数（数据完整性）

观察点:
- 100% 成功率
- 零错误率
- 数据完整性良好

断言:
✓ 成功操作数 === 总操作数
✓ 错误数 === 0
```

---

### 3. 基础可靠性（2个场景）

#### S6: 超时处理（模拟过期锁）
```typescript
测试步骤:
1. 创建一个过期的锁文件（PID=99999，时间戳=31秒前）
2. 尝试获取锁
3. 验证能否清理过期锁并获取新锁

验证点:
✓ acquired === true（清理成功）
✓ isLocked() === true
✓ getLockPid() === 当前进程 PID
```

#### S7: 错误恢复（异常情况处理）
```typescript
场景1: 锁文件被外部删除
- 持有锁期间，外部删除锁文件
- 调用 releaseLock() 应该正常处理
- 能够重新获取锁

场景2: 并发竞争失败后重试
- 主进程持有锁
- 另一进程尝试获取（失败）
- 100ms 后主进程释放锁
- 另一进程通过重试机制成功获取

场景3: 处理损坏的锁文件
- 锁文件内容损坏（非数字）
- 尝试获取锁应该能处理并成功

断言:
✓ 所有场景都能成功恢复
```

---

## 测试参数对比

| 参数 | 任务7（探索性） | 后续任务（参考） |
|------|-----------------|------------------|
| 单次延迟迭代 | 100 | 1000+ |
| 并发 Worker | 3 | 10-20 |
| 每 Worker 操作数 | 30 | 100+ |
| 总操作数 | 90 | 1000+ |
| 性能阈值 | 无（观察点） | 有严格阈值 |
| 测试时长 | 短（秒级） | 长（秒到分钟） |

## 辅助工具函数

### 性能指标计算
```typescript
calculateMetrics(values: number[]): PerformanceMetrics
  返回: { min, max, avg, p50, p95, p99 }
```

### 锁机制模拟
```typescript
acquireLock(): boolean
  - 检查现有锁
  - 检查是否过期（30秒）
  - 创建新锁文件（exclusive write）

releaseLock(): void
  - 删除锁文件
  - 重置状态

withLock<T>(fn: () => T): T
  - 最多重试 10 次
  - 每次延迟 100ms
  - 自动释放锁

isLocked(): boolean
  - 检查锁文件是否存在

getLockPid(): number | null
  - 读取锁文件中的 PID
```

### 环境管理
```typescript
setupTestEnv(): void
  - 创建临时目录
  - 初始化队列文件

cleanupTestEnv(): void
  - 清理锁文件
  - 清理队列文件
  - 重置状态
```

## 测试执行流程

```
1. beforeEach → setupTestEnv()
   ├─ 创建 /tmp/cah-lock-test7-{timestamp}/
   ├─ 创建 queue.json
   └─ 初始化空队列

2. 执行测试
   ├─ S1-S3: 基本功能验证（功能正确性）
   ├─ S4-S5: 初步性能测试（数据收集）
   └─ S6-S7: 基础可靠性（异常处理）

3. afterEach → cleanupTestEnv()
   ├─ 删除锁文件
   ├─ 删除队列文件
   └─ 重置状态

4. 全局 afterEach
   └─ 删除整个临时目录
```

## 预期输出格式

### 控制台输出示例
```
[S1] 锁的基本获取和释放
首次获取锁: true
重复获取锁: true
释放锁后状态: false
再次获取锁: true
✓ 基本获取/释放功能正常

[S4] 单次操作延迟测试
迭代次数: 100
平均延迟: 0.123ms
中位数(P50): 0.110ms
P95: 0.180ms, P99: 0.250ms
最小: 0.080ms, 最大: 0.350ms

观察点:
✓ 平均延迟良好（< 1ms）

[S5] 简单并发测试
Worker 数量: 3
每个 Worker 操作数: 30
成功操作: 90/90
总耗时: 123.45ms
平均延迟: 1.234ms
错误数: 0
写入任务数: 90

观察点:
✓ 100% 成功率
✓ 零错误率
✓ 数据完整性良好
```

## 成功标准

### 功能正确性（必须满足）
- ✓ S1-S3: 所有基本功能测试通过
- ✓ S5: 100% 成功率，零错误率
- ✓ S6-S7: 所有异常场景正确处理

### 性能观察（数据收集）
- S4: 记录单次延迟分布
- S5: 记录并发场景性能

### 数据产出（用于后续分析）
- 性能指标数据（min/max/avg/p50/p95/p99）
- 错误率和成功率
- 并发场景下的吞吐量

## 后续优化方向

基于任务7的探索性结果，后续任务可能的优化方向：
1. **参数调优**: 增加迭代次数、Worker 数量
2. **场景扩展**: 添加更复杂的并发场景
3. **性能目标**: 设置严格的性能阈值
4. **压力测试**: 长时间运行、高频操作
5. **死锁检测**: 更复杂的死锁场景

---

**配置状态**: ✓ 就绪，可执行测试
