/**
 * Save task execution output to markdown file
 * Output path: outputs/YYYY-MM-DD/TaskTitle_shortId.md
 */

import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import { formatTime, now, formatDuration, timeDiff } from '../shared/time.js'
import { shortenId } from '../shared/id.js'
import { createLogger } from '../shared/logger.js'
import type { TaskExecutionResult, StepOutput } from '../types/output.js'

const logger = createLogger('output')

/**
 * Sanitize filename - remove invalid chars, limit length
 */
function sanitizeFilename(name: string): string {
  return name
    .replace(/[<>:"/\\|?*\x00-\x1f]/g, '') // Remove invalid chars
    .replace(/\s+/g, '_')                   // Replace spaces with underscore
    .replace(/_+/g, '_')                    // Collapse multiple underscores
    .slice(0, 50)                           // Limit length
    .replace(/^_+|_+$/g, '')                // Trim leading/trailing underscores
}

/**
 * Get output directory path for today
 */
function getOutputDir(): string {
  const today = formatTime(now(), 'yyyy-MM-dd')
  return join(process.cwd(), 'outputs', today)
}

/**
 * Build output filename
 */
function buildFilename(taskTitle: string, taskId: string): string {
  const sanitized = sanitizeFilename(taskTitle) || 'task'
  const shortId = shortenId(taskId, 8)
  return `${sanitized}_${shortId}.md`
}

/**
 * Format task execution result as markdown
 */
function formatTaskOutput(result: TaskExecutionResult): string {
  const { task, agent, branch, plan, stepOutputs, timing } = result
  const lines: string[] = []

  // Header
  lines.push(`# ${task.title}`)
  lines.push('')

  // Task Info
  lines.push('## Task Info')
  lines.push('')
  lines.push(`- **Task ID:** \`${task.id}\``)
  lines.push(`- **Agent:** ${agent.name} (${agent.persona})`)
  lines.push(`- **Branch:** \`${branch}\``)
  lines.push(`- **Priority:** ${task.priority}`)
  lines.push(`- **Started:** ${formatTime(timing.startedAt)}`)
  lines.push(`- **Completed:** ${formatTime(timing.completedAt)}`)
  lines.push(`- **Duration:** ${formatDuration(timeDiff(timing.startedAt, timing.completedAt))}`)
  lines.push('')

  // Description
  if (task.description) {
    lines.push('## Description')
    lines.push('')
    lines.push(task.description)
    lines.push('')
  }

  // Execution Plan
  lines.push('## Execution Plan')
  lines.push('')
  lines.push(`**Analysis:** ${plan.analysis}`)
  lines.push('')
  lines.push(`**Estimated Effort:** ${plan.estimatedEffort}`)
  lines.push('')

  if (plan.risks.length > 0) {
    lines.push('**Risks:**')
    for (const risk of plan.risks) {
      lines.push(`- ${risk}`)
    }
    lines.push('')
  }

  lines.push('**Steps:**')
  lines.push('')
  for (const step of plan.steps) {
    lines.push(`${step.order}. ${step.action}`)
    if (step.files.length > 0) {
      lines.push(`   - Files: ${step.files.join(', ')}`)
    }
  }
  lines.push('')

  // Execution Output
  lines.push('## Execution Output')
  lines.push('')

  for (const stepOutput of stepOutputs) {
    lines.push(`### Step ${stepOutput.stepOrder}: ${stepOutput.action}`)
    lines.push('')
    lines.push(`**Duration:** ${formatDuration(stepOutput.durationMs)}`)
    if (stepOutput.files.length > 0) {
      lines.push(`**Files:** ${stepOutput.files.join(', ')}`)
    }
    lines.push('')
    lines.push('```')
    lines.push(truncateOutput(stepOutput.output))
    lines.push('```')
    lines.push('')
  }

  // Footer
  lines.push('---')
  lines.push(`*Generated by Claude Agent Hub at ${formatTime(now())}*`)

  return lines.join('\n')
}

/**
 * Truncate very long output to avoid huge files
 */
function truncateOutput(output: string, maxLength: number = 50000): string {
  if (output.length <= maxLength) return output
  const truncated = output.slice(0, maxLength)
  return `${truncated}\n\n[... truncated, total ${output.length} characters ...]`
}

/**
 * Save task execution output to file
 * @returns The path of the saved file
 */
export async function saveTaskOutput(result: TaskExecutionResult): Promise<string> {
  const dir = getOutputDir()

  try {
    await mkdir(dir, { recursive: true })
  } catch (err) {
    logger.warn(`Failed to create output directory: ${dir}`, err)
    throw err
  }

  const filename = buildFilename(result.task.title, result.task.id)
  const filepath = join(dir, filename)
  const content = formatTaskOutput(result)

  try {
    await writeFile(filepath, content, 'utf-8')
    logger.info(`Output saved: ${filepath}`)
    return filepath
  } catch (err) {
    logger.error(`Failed to write output file: ${filepath}`, err)
    throw err
  }
}
